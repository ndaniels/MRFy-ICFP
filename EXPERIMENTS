NR's Qs
=======
(1) What did you change?
(2) Why did you change it? (What was the question or hypothesis) 
(3) what were the results? On what machines and benchmarks? Measured with 
    what tools?


Short benchmark on ICFP
=======================
8.hmm+         4.480000  x86_64  Intel i7-3930K
barwin.hmm+    1.010000  x86_64  Intel i7-3930K
micro8.hmm+    0.040000  x86_64  Intel i7-3930K
sandwich.hmm+  4.020000  x86_64  Intel i7-3930K
total          9.550000  x86_64  Intel i7-3930K
Commit: 2f9bd4fbc20ef50702bed2a01059f04bcdf03b44


AG attempt 1
three-node-record
=================
(1) Adapted NR's hoViterbi with a new "Model" representation of an HMM.
    e.g., constant time slicing with arrays

(2) Speed up Viterbi relative to C++ by reducing the amount of case
    analysis without leaving the essentially index-based nature of
    the computation.

(3) Results of short benchmark:

    8.hmm+         5.310000   x86_64  Intel i7-3930K
    barwin.hmm+    1.590000   x86_64  Intel i7-3930K
    micro8.hmm+    0.540000   x86_64  Intel i7-3930K
    sandwich.hmm+  4.840000   x86_64  Intel i7-3930K
    total          12.280000  x86_64  Intel i7-3930K
    Commit: feccfc1d3821e06ace71945f894a00db749aef98

    Problem: it's ~30% slower.


AG attempt 2
three-node-record-orig-array
============================
(1) Adapted AG#1 to use the original array `HMM` type from ICFP.

(2) AG#1 was slow. Rule out a possibility for the slow down.

(3) Results of short benchmark:

    8.hmm+         5.340000   x86_64  Intel i7-3930K
    barwin.hmm+    1.610000   x86_64  Intel i7-3930K
    micro8.hmm+    0.560000   x86_64  Intel i7-3930K
    sandwich.hmm+  4.830000   x86_64  Intel i7-3930K
    total          12.340000  x86_64  Intel i7-3930K
    Commit: 01a74a28769343611122fd2e92a49cc309648b17


AG attempt 3
three-node-record-orig-array-func
=================================
(1) Adapted AG#2 to compute `preceders` with case analysis in lieu
    of an array.

(2) AG#2 showed no noticeable improvement over AG#1, so we want to
    rule out more possibilities.

(3) Results of short benchmark:

    8.hmm+         4.830000   x86_64  Intel i7-3930K
    barwin.hmm+    1.510000   x86_64  Intel i7-3930K
    micro8.hmm+    0.550000   x86_64  Intel i7-3930K
    sandwich.hmm+  4.390000   x86_64  Intel i7-3930K
    total          11.280000  x86_64  Intel i7-3930K
    Commit: 910383cfc3a87a0f19460e59ae32d1a02c1fb869

    Problem: it's still 17.5% slower than our ICFP version.
    It looks like `preceders` wasn't being memoized? Why?


AG attempt 4
three-node-record-orig-func
=================================
(1) Adapted AG#1 to compute `preceders` with case analysis in lieu
    of an array. This is just like AG#3, but using the new HMM
    representation.

(2) Try to narrow down the performance hit.

(3) Results of short benchmark:

    8.hmm+         4.750000   x86_64  Intel i7-3930K
    barwin.hmm+    1.460000   x86_64  Intel i7-3930K
    micro8.hmm+    0.540000   x86_64  Intel i7-3930K
    sandwich.hmm+  4.340000   x86_64  Intel i7-3930K
    total          11.090000  x86_64  Intel i7-3930K
    Commit: c38d37c0729bb94430f1904e22e5a0cdd3f7a4ec

    OK. Not much change from AG#3, so it seems like the
    representation of an HMM isn't at fault here.


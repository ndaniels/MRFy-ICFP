everyPt :: RandomGen r
        => SearchGen pt r -> CCost -> Scored pt
        -> Rand r [CCosted (Utility (Scored pt))]
everyPt sg cost startPt = do
  successors <- mapM (nextPt sg) (repeat startPt)
  tagged <- zipWithM costedUtility successors [succ cost..]
  let (useless, CCosted (Useful newPt) newCost : _) =
                      span (isUseless . unCCosted) tagged
  ((CCosted (Useful startPt) cost : useless) ++) <$>
                                  everyPt sg newCost newPt
 where costedUtility pt cost =
         utility sg move >>= \u -> return $ CCosted u cost
        where move = Move { older = startPt, younger = pt
                          , youngerCCost = cost }

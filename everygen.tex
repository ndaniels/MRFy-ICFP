everyPt :: RandomGen r
        => SearchGen pt r -> Age -> Scored pt
        -> Rand r [Aged (Utility (Scored pt))]
everyPt sg age startPt = do
  successors <- mapM (nextPt sg) (repeat startPt)
  tagged <- zipWithM agedUtility successors [succ age..]
  let (useless, Aged (Useful newPt) newAge : _) =
                        span (isUseless . unAged) tagged
  nextPts <- everyPt sg newAge newPt
  return $ Aged (Useful startPt) age : useless ++ nextPts

  where agedUtility pt age =
           utility sg move >>= \u -> return $ Aged u age
         where move = Move { older = startPt, younger = pt
                           , youngerAge = age }
